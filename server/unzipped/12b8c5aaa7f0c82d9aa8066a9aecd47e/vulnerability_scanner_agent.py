"""
Vulnerability Scanner Agent - Main Integration Module

This module integrates all the vulnerability scanning components into a cohesive ADK agent.
It combines the CVE data collector, EPSS score collector, CISA KEV collector, and patch link finder
to create a comprehensive vulnerability scanning agent.
"""

import os
import json
from typing import Dict, List, Any, Optional

from google.adk import Agent, Runner
from google.adk.agents import LlmAgent
from google.adk.sessions import InMemorySessionService

# Import the component tools
from cve_data_collector import cve_tool
from epss_score_collector import epss_tool
from cisa_kev_collector import kev_tool
from patch_link_finder import patch_tool

# Agent instructions
AGENT_INSTRUCTIONS = """
You are a vulnerability scanning agent that helps users find information about 
security vulnerabilities from multiple sources including CVE.org, EPSS, and CISA KEV.
You can also find patch links when available.

When a user asks about a vulnerability:
1. Search for the vulnerability in the CVE database using the cve_data_collector tool
2. Get the EPSS score using the epss_score_collector tool to determine exploitation likelihood
3. Check if it's in the CISA KEV catalog using the cisa_kev_collector tool (actively exploited)
4. Find patch links using the patch_link_finder tool if available
5. Present the information in a prioritized, easy-to-understand format

You can also search for vulnerabilities by keywords or date ranges.

Examples of what you can do:
- Look up information about a specific CVE (e.g., "Tell me about CVE-2021-44228")
- Search for vulnerabilities by keyword (e.g., "Find vulnerabilities related to log4j")
- Check if vulnerabilities are being actively exploited (e.g., "Is CVE-2021-44228 being exploited?")
- Find patch information (e.g., "Where can I find patches for CVE-2021-44228?")
- Get recent additions to the CISA KEV catalog (e.g., "What vulnerabilities were recently added to CISA KEV?")

Always prioritize vulnerabilities that:
1. Are in the CISA KEV catalog (highest priority - actively exploited)
2. Have high EPSS scores (higher scores indicate greater likelihood of exploitation)
3. Have high CVSS scores (standard severity rating)
4. Lack available patches (vulnerabilities without patches are higher priority)
"""

def create_vulnerability_scanner_agent() -> Agent:
    """
    Create and configure the vulnerability scanner agent with all tools.
    
    Returns:
        Configured ADK agent
    """
    # Create the agent with all tools
    agent = LlmAgent(
        name="VulnerabilityScanner",
        tools=[cve_tool, epss_tool, kev_tool, patch_tool]
    )
    
    return agent

def create_runner(agent: Agent) -> Runner:
    """
    Create a runner for the agent with session service.
    
    Args:
        agent: The configured ADK agent
        
    Returns:
        Runner for the agent
    """
    # Create a runner with in-memory session service
    runner = Runner(
        agent=agent,
        session_service=InMemorySessionService(),
        app_name="VulnerabilityScannerApp"
    )
    
    return runner

def process_vulnerability_data(cve_data: Dict[str, Any], 
                              epss_data: Dict[str, Any], 
                              kev_data: Dict[str, Any],
                              patch_data: Dict[str, Any]) -> Dict[str, Any]:
    """
    Process and combine data from all sources into a unified vulnerability report.
    
    Args:
        cve_data: Data from CVE collector
        epss_data: Data from EPSS collector
        kev_data: Data from CISA KEV collector
        patch_data: Data from patch link finder
        
    Returns:
        Unified vulnerability report
    """
    # Extract vulnerabilities from CVE data
    vulnerabilities = cve_data.get("result", {}).get("vulnerabilities", [])
    
    # Create a mapping of CVE IDs to EPSS scores
    epss_scores = {}
    for score_info in epss_data.get("result", {}).get("scores", []):
        epss_scores[score_info.get("cve_id")] = {
            "epss_score": score_info.get("epss_score"),
            "percentile": score_info.get("percentile")
        }
    
    # Create a mapping of CVE IDs to KEV information
    kev_info = {}
    for vuln_info in kev_data.get("result", {}).get("vulnerabilities", []):
        kev_info[vuln_info.get("cve_id")] = {
            "in_catalog": vuln_info.get("in_catalog"),
            "kev_info": vuln_info.get("kev_info")
        }
    
    # Create a mapping of CVE IDs to patch information
    patch_info = {}
    if "results" in patch_data.get("result", {}):
        # Batch result
        for patch_result in patch_data.get("result", {}).get("results", []):
            patch_info[patch_result.get("cve_id")] = {
                "patch_links": patch_result.get("patch_links", []),
                "vendor_advisories": patch_result.get("vendor_advisories", [])
            }
    else:
        # Single result
        cve_id = patch_data.get("result", {}).get("cve_id")
        if cve_id:
            patch_info[cve_id] = {
                "patch_links": patch_data.get("result", {}).get("patch_links", []),
                "vendor_advisories": patch_data.get("result", {}).get("vendor_advisories", [])
            }
    
    # Combine all data into a unified report
    unified_report = {
        "vulnerabilities": []
    }
    
    for vuln in vulnerabilities:
        cve_id = vuln.get("cve_id")
        
        # Create a comprehensive vulnerability entry
        vuln_report = {
            "cve_id": cve_id,
            "description": vuln.get("description"),
            "published": vuln.get("published"),
            "last_modified": vuln.get("last_modified"),
            "cvss_v3": vuln.get("cvss_v3", {}),
            "cvss_v2": vuln.get("cvss_v2", {}),
            "references": vuln.get("references", []),
            "epss": epss_scores.get(cve_id, {}),
            "in_kev_catalog": kev_info.get(cve_id, {}).get("in_catalog", False),
            "kev_info": kev_info.get(cve_id, {}).get("kev_info"),
            "patch_links": patch_info.get(cve_id, {}).get("patch_links", []),
            "vendor_advisories": patch_info.get(cve_id, {}).get("vendor_advisories", [])
        }
        
        # Calculate risk score for prioritization
        risk_score = calculate_risk_score(vuln_report)
        vuln_report["risk_score"] = risk_score
        
        unified_report["vulnerabilities"].append(vuln_report)
    
    # Sort vulnerabilities by risk score (descending)
    unified_report["vulnerabilities"].sort(key=lambda x: x.get("risk_score", 0), reverse=True)
    
    return unified_report

def calculate_risk_score(vuln_report: Dict[str, Any]) -> float:
    """
    Calculate a risk score for prioritization based on various factors.
    
    Args:
        vuln_report: Vulnerability report data
        
    Returns:
        Risk score (higher is more critical)
    """
    risk_score = 0.0
    
    # Factor 1: CISA KEV catalog (highest weight)
    if vuln_report.get("in_kev_catalog", False):
        risk_score += 100.0
    
    # Factor 2: EPSS score (0-100 scale)
    epss_score = vuln_report.get("epss", {}).get("epss_score")
    if epss_score is not None:
        risk_score += float(epss_score) * 100.0
    
    # Factor 3: CVSS v3 score (0-10 scale, weighted)
    cvss_score = vuln_report.get("cvss_v3", {}).get("base_score")
    if cvss_score is not None:
        risk_score += float(cvss_score) * 5.0
    
    # Factor 4: Patch availability (lack of patches increases risk)
    if not vuln_report.get("patch_links"):
        risk_score += 10.0
    
    return risk_score

def run_agent_interactive():
    """Run the agent in interactive mode for testing."""
    # Create the agent and runner
    agent = create_vulnerability_scanner_agent()
    runner = create_runner(agent)
    
    print("Vulnerability Scanner Agent initialized.")
    print("Type 'exit' to quit.")
    
    while True:
        user_input = input("\nEnter your query: ")
        
        if user_input.lower() == 'exit':
            break
        
        # Process the user input
        response = runner.run(user_input)
        
        # Print the response
        print("\nAgent response:")
        print(response.text)

def main():
    """Main entry point for the vulnerability scanner agent."""
    # Create the agent and runner
    agent = create_vulnerability_scanner_agent()
    runner = create_runner(agent)
    
    # Example usage
    if os.environ.get("INTERACTIVE_MODE", "false").lower() == "true":
        run_agent_interactive()
    else:
        # Run a sample query
        response = runner.run("Tell me about CVE-2021-44228")
        print(response.text)

if __name__ == "__main__":
    main()
